# -*- coding: utf-8 -*-
"""mci_to_ad_transfer_learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vj5SdXhuP3PHvsEhzjaSDf6I3Z95-luh
"""

!pip install kaggle

from google.colab import files
files.upload()

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d samahabuayied/mci-to-ad-mri-dataset
!unzip mci-to-ad-mri-dataset.zip -d mci_to_ad_dataset

import os

base_path = "mci_to_ad_dataset"
for folder in os.listdir(base_path):
    print(folder, "→", len(os.listdir(os.path.join(base_path, folder))), "files")

import os

base_path = "mci_to_ad_dataset"

for root, dirs, files in os.walk(base_path):
    print(root, "->", len(files), "files")

import os, shutil

src_dir = "mci_to_ad_dataset/train/train"  # مكان الصور الحالية
dst_base = "mci_to_ad_dataset/train_sorted"

# إنشاء مجلدات الفئات الأربعة
classes = ["EMCI", "LMCI", "MCI", "AD"]
for cls in classes:
    os.makedirs(os.path.join(dst_base, cls), exist_ok=True)

# توزيع الصور حسب اسم الملف
counts = {cls: 0 for cls in classes}

for file in os.listdir(src_dir):
    src_path = os.path.join(src_dir, file)

    # نتأكد إنه صورة
    if not file.lower().endswith(('.png', '.jpg', '.jpeg')):
        continue

    # نحدد الفئة من اسم الصورة
    for cls in classes:
        if cls in file.upper():  # لو اسم الصورة يحتوي EMCI أو LMCI أو MCI أو AD
            shutil.copy(src_path, os.path.join(dst_base, cls, file))
            counts[cls] += 1
            break

print("✅ تم توزيع الصور كالتالي:")
print(counts)

from tensorflow.keras.preprocessing.image import ImageDataGenerator

img_size = (224, 224)
batch_size = 32

datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=10,
    zoom_range=0.1,
    horizontal_flip=True
)

train_generator = datagen.flow_from_directory(
    "mci_to_ad_dataset/train_sorted",
    target_size=img_size,
    batch_size=batch_size,
    class_mode='categorical',  # ✅ multi-class
    subset='training'
)

val_generator = datagen.flow_from_directory(
    "mci_to_ad_dataset/train_sorted",
    target_size=img_size,
    batch_size=batch_size,
    class_mode='categorical',
    subset='validation'
)

from tensorflow.keras.preprocessing.image import ImageDataGenerator

img_size = (224, 224)
batch_size = 32

datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=10,
    zoom_range=0.1,
    horizontal_flip=True
)

train_generator = datagen.flow_from_directory(
    "mci_to_ad_dataset/train_sorted",
    target_size=img_size,
    batch_size=batch_size,
    class_mode='categorical',
    subset='training'
)

val_generator = datagen.flow_from_directory(
    "mci_to_ad_dataset/train_sorted",
    target_size=img_size,
    batch_size=batch_size,
    class_mode='categorical',
    subset='validation'
)

from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam

# تحميل النموذج الأساسي
base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.trainable = False  # تجميد الطبقات

# إضافة طبقات التصنيف
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dropout(0.3)(x)
output = Dense(4, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=output)

model.compile(optimizer=Adam(learning_rate=0.0001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

history = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=10
)

for layer in base_model.layers[-50:]:
    layer.trainable = True

model.compile(optimizer=Adam(learning_rate=1e-5),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

history_ft = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=5
)

import numpy as np
from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns
import matplotlib.pyplot as plt
# الحصول على التنبؤات
val_generator.reset()
preds = model.predict(val_generator)
y_pred = np.argmax(preds, axis=1)

# القيم الحقيقية
y_true = val_generator.classes

cm = confusion_matrix(y_true, y_pred)
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=val_generator.class_indices.keys(), yticklabels=val_generator.class_indices.keys())
plt.xlabel("Predicted")
plt.ylabel("True")
plt.show()

print(classification_report(y_true, y_pred, target_names=val_generator.class_indices.keys()))

model.save("mci_to_ad_efficientnet.h5")

import numpy as np
import matplotlib.pyplot as plt

# أخذ عينة من صور الـ validation
x_batch, y_batch = next(val_generator)   # أول batch من val_generator
preds = model.predict(x_batch)           # تنبؤ النموذج
pred_labels = np.argmax(preds, axis=1)   # التنبؤ الفعلي
true_labels = np.argmax(y_batch, axis=1) # التصنيف الحقيقي

# أسماء الفئات
class_names = list(val_generator.class_indices.keys())

plt.figure(figsize=(14, 8))

# نعرض 8 صور فقط كعينة
for i in range(8):
    plt.subplot(2, 4, i+1)
    plt.imshow(x_batch[i])
    plt.axis("off")

    true_class = class_names[true_labels[i]]
    pred_class = class_names[pred_labels[i]]

    color = "green" if true_class == pred_class else "red"
    plt.title(f"True: {true_class}\nPred: {pred_class}", color=color)

plt.tight_layout()
plt.show()